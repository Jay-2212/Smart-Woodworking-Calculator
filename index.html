<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WoodWork Smart Calculator</title>
    
    <!-- 1. STYLE ENGINE (Tailwind CSS) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. THE BRAIN (React & Babel) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { overscroll-behavior-y: none; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; margin: 0; 
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 font-sans pb-40 select-none">

    <div id="root"></div>

    <!-- 3. THE APP LOGIC -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONS ---
        const Icon = ({ path, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
        );

        const Icons = {
            Box: (p) => <Icon {...p} path={<><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></>} />,
            Plus: (p) => <Icon {...p} path={<><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></>} />,
            Trash: (p) => <Icon {...p} path={<><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></>} />,
            Settings: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></>} />,
        };

        // --- HELPERS ---
        const getPurchasedFeet = (inches) => {
            const feet = inches / 12;
            const whole = Math.floor(feet);
            const fraction = feet - whole;
            if (fraction === 0) return whole;
            if (fraction <= 0.5001) return whole + 0.5;
            return whole + 1.0;
        };

        const calculateLineCFT = (l, w, t, qty) => {
            const feet = getPurchasedFeet(l);
            return ((feet * w * t) / 144) * qty;
        };

        const getSizeDims = (sizeStr) => {
            const map = {
                '3x1': {w:3, t:1}, '4x1': {w:4, t:1}, 
                '3x1.5': {w:3, t:1.5}, '4x1.5': {w:4, t:1.5},
                '3x2': {w:3, t:2}, '4x2': {w:4, t:2}, 
                '4x3': {w:4, t:3}
            };
            return map[sizeStr] || {w:3, t:1};
        };

        const getMaxDim = (sizeStr) => {
            if(!sizeStr) return 0;
            const parts = sizeStr.split('x').map(parseFloat);
            return Math.max(...parts);
        };

        const estimateRunners = (length) => {
            const l = parseFloat(length) || 0;
            if (l >= 75) return 5;
            if (l >= 60) return 4;
            if (l >= 50) return 3;
            return 2; 
        };

        // --- CRATE LOGIC ---
        // Calculates wood needed to cover a 'span' with planks and gaps
        const calculateCrateEffectiveLength = (span, plankWidth, gap) => {
            if (!span || span <= 0) return 0;
            const unit = plankWidth + gap;
            // How many planks? Ceil ensures we cover the end or start/end structure
            const planks = Math.ceil(span / unit);
            // Return total width of WOOD
            return planks * plankWidth;
        };

        const getEffectiveCrateDims = (partName, l, w, boxType, crateSettings) => {
            // Default: Solid (No change)
            let effL = l;
            let effW = w;
            let note = null;

            // Logic Switch based on Orientation
            if (partName === 'Sides') {
                if (boxType === 'simple' || boxType === 'crateSimple') {
                    // SIMPLE CRATE SIDE:
                    // Runners Vertical -> Maal Horizontal
                    // Stack planks along HEIGHT (w). Length (l) is solid plank length.
                    const originalH = w;
                    effW = calculateCrateEffectiveLength(originalH, crateSettings.plank, crateSettings.gap);
                    note = `(Height ${originalH}" → Wood ${effW}")`;
                } else {
                    // BOTTOM CRATE SIDE:
                    // Runners Horizontal -> Maal Vertical
                    // Stack planks along LENGTH (l). Height (w) is solid plank length.
                    const originalL = l;
                    effL = calculateCrateEffectiveLength(originalL, crateSettings.plank, crateSettings.gap);
                    note = `(Length ${originalL}" → Wood ${effL}")`;
                }
            } 
            else if (partName === 'Kara') {
                // KARA (Both Types):
                // Runners Vertical -> Maal Horizontal
                // Stack planks along HEIGHT (w). Width (l) is solid plank length.
                const originalH = w;
                effW = calculateCrateEffectiveLength(originalH, crateSettings.plank, crateSettings.gap);
                note = `(Height ${originalH}" → Wood ${effW}")`;
            }
            else if (partName === 'Top') {
                // TOP (Both Types):
                // Runners Width-wise -> Maal Length-wise
                // Stack planks along WIDTH (w). Length (l) is solid plank length.
                const originalW = w;
                effW = calculateCrateEffectiveLength(originalW, crateSettings.plank, crateSettings.gap);
                note = `(Width ${originalW}" → Wood ${effW}")`;
            }

            return { l: effL, w: effW, note };
        };

        // --- COMPONENTS ---

        const NumberInput = ({ value, onChange, className = "", step = 0.125 }) => (
            <input 
                type="number" 
                value={value} 
                onChange={(e) => { const val = e.target.value; onChange(val === '' ? '' : parseFloat(val)); }} 
                step={step}
                className={`w-full bg-white border-2 border-slate-300 rounded-md px-2 py-2 text-center font-mono font-bold text-lg text-slate-900 focus:ring-4 focus:ring-amber-200 focus:border-amber-500 outline-none transition-all ${className}`}
            />
        );

        const CalculationRow = ({ label, data, onChange, isCrate, crateSettings, boxType }) => {
            let effL = data.l || 0;
            let effW = data.w || 0;
            let note = null;

            // Apply Crate Logic if needed
            if (isCrate) {
                // Identify Part Name for Logic
                let partName = '';
                if (label.includes('Sides')) partName = 'Sides';
                else if (label.includes('Kara')) partName = 'Kara';
                else if (label.includes('Top')) partName = 'Top';

                if (partName) {
                    // Determine internal sub-type for logic (simple vs bottom)
                    // If label passed boxType 'crate', we need to know if it is 'crateSimple' or 'crateBottom'
                    // We pass 'crateSimple' or 'crateBottom' directly in props now
                    const res = getEffectiveCrateDims(partName, data.l, data.w, boxType, crateSettings);
                    effL = res.l;
                    effW = res.w;
                    note = res.note;
                }
            }

            const cft = calculateLineCFT(effL, effW, data.t || 0, data.qty || 0);

            return (
                <div className={`grid grid-cols-12 gap-2 items-center border-b border-slate-200 py-3 last:border-0 ${isCrate && note ? 'bg-amber-50/50' : ''}`}>
                    <div className="col-span-3">
                        <div className="text-sm font-black text-slate-700 uppercase tracking-tight leading-tight">{label}</div>
                        {isCrate && note && <div className="text-[9px] font-bold text-amber-600 uppercase tracking-wider">Crate Gap</div>}
                    </div>
                    <div className="col-span-2 relative">
                        <NumberInput value={data.l} onChange={(v) => onChange('l', v)} />
                        {isCrate && note && note.includes("Length") && <div className="absolute -bottom-3 left-0 w-full text-[8px] text-center font-bold text-amber-600">Wood: {effL}</div>}
                    </div>
                    <div className="col-span-2 relative">
                        <NumberInput value={data.w} onChange={(v) => onChange('w', v)} />
                        {isCrate && note && (note.includes("Height") || note.includes("Width")) && <div className="absolute -bottom-3 left-0 w-full text-[8px] text-center font-bold text-amber-600">Wood: {effW}</div>}
                    </div>
                    <div className="col-span-2"><NumberInput value={data.t} onChange={(v) => onChange('t', v)} step={0.25} /></div>
                    <div className="col-span-1"><NumberInput value={data.qty} onChange={(v) => onChange('qty', v)} className="px-0" step={1} /></div>
                    <div className="col-span-2 text-right font-mono font-black text-amber-700 text-base">{cft.toFixed(2)}</div>
                </div>
            );
        };

        const SupportCard = ({ label, sizeOptions, dimOptions, settings, onUpdate, colorClass="bg-white" }) => {
            const sDims = getSizeDims(settings.size);
            const feet = getPurchasedFeet(settings.dim);
            const cft = ((feet * sDims.w * sDims.t) / 144) * settings.count;

            return (
                <div className={`rounded-xl shadow-md border-2 border-slate-200 overflow-hidden ${colorClass}`}>
                    <div className="p-3 border-b border-slate-200 flex justify-between items-center bg-slate-100">
                        <span className="text-sm font-black text-slate-700 uppercase tracking-wide">{label}</span>
                        <span className="font-mono font-black text-xl text-amber-700">{cft.toFixed(2)} <span className="text-xs text-slate-400">CFT</span></span>
                    </div>
                    <div className="p-4 space-y-4">
                        <div>
                            <label className="text-xs text-slate-500 font-black mb-1 uppercase block tracking-wider">Size (Width x Thick)</label>
                            <select 
                                value={settings.size} 
                                onChange={(e) => onUpdate('size', e.target.value)}
                                className="w-full bg-white border-2 border-slate-300 rounded-md py-3 px-3 text-xl font-bold text-slate-900 focus:ring-4 focus:ring-amber-200 outline-none"
                            >
                                {sizeOptions.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                        </div>
                        <div className="flex items-center gap-3">
                            <div className="flex-grow">
                                <label className="text-xs text-slate-500 font-black mb-1 uppercase block tracking-wider">Length (Inches)</label>
                                <select 
                                    value={settings.dim} 
                                    onChange={(e) => onUpdate('dim', parseFloat(e.target.value))}
                                    className="w-full bg-white border-2 border-slate-300 rounded-md py-3 px-3 text-xl font-bold text-slate-900 focus:ring-4 focus:ring-amber-200 outline-none"
                                >
                                    {dimOptions.map(d => <option key={d.val} value={d.val}>{d.label}</option>)}
                                </select>
                            </div>
                            <div className="w-24">
                                <label className="text-xs text-slate-500 font-black mb-1 uppercase block text-right tracking-wider">Purchase</label>
                                <div className="bg-amber-50 border-2 border-amber-100 rounded-md py-2 px-2 text-right">
                                    <span className="text-xl font-black text-amber-800">{feet.toFixed(1)}</span>
                                    <span className="text-xs text-slate-500 ml-1 font-bold">ft</span>
                                </div>
                            </div>
                        </div>
                        <div>
                            <label className="text-xs text-slate-500 font-black mb-1 uppercase block tracking-wider">Quantity</label>
                            <NumberInput value={settings.count} onChange={(v) => onUpdate('count', v)} step={1} className="py-3 text-2xl font-black bg-slate-50" />
                        </div>
                    </div>
                </div>
            );
        };

        const BoxTypeSelector = ({ type, setType, subType, setSubType, crateSettings, setCrateSettings }) => {
            return (
                <div className="bg-white p-3 rounded-xl shadow-sm border-2 border-slate-200 mb-4 transition-all">
                    <label className="text-[10px] text-slate-500 font-black uppercase tracking-wide block mb-2">Select Box Type</label>
                    <div className="grid grid-cols-3 gap-2">
                        {['simple', 'bottom', 'crate'].map(t => (
                            <button 
                                key={t}
                                onClick={() => setType(t)}
                                className={`py-3 px-1 rounded-lg text-sm font-black uppercase tracking-wider transition-all ${
                                    type === t 
                                    ? 'bg-amber-600 text-white ring-2 ring-amber-300 ring-offset-1 shadow-md' 
                                    : 'bg-slate-100 text-slate-400 hover:bg-slate-200'
                                }`}
                            >
                                {t}
                            </button>
                        ))}
                    </div>
                    
                    {type === 'crate' && (
                        <div className="mt-3 pt-3 border-t-2 border-slate-100 animate-fade-in">
                            <div className="grid grid-cols-2 gap-2 mb-3">
                                <button 
                                    onClick={() => setSubType('simple')}
                                    className={`py-2 text-xs font-bold uppercase rounded-lg border-2 ${subType === 'simple' ? 'bg-blue-50 border-blue-200 text-blue-700' : 'bg-white border-transparent text-slate-300'}`}
                                >
                                    Simple Crate
                                </button>
                                <button 
                                    onClick={() => setSubType('bottom')}
                                    className={`py-2 text-xs font-bold uppercase rounded-lg border-2 ${subType === 'bottom' ? 'bg-blue-50 border-blue-200 text-blue-700' : 'bg-white border-transparent text-slate-300'}`}
                                >
                                    Bottom Crate
                                </button>
                            </div>

                            <div className="grid grid-cols-2 gap-4 bg-slate-50 p-3 rounded-lg border border-slate-200">
                                <div>
                                    <label className="text-[9px] text-slate-500 font-black uppercase block mb-1">Plank Width</label>
                                    <div className="flex items-center bg-white border border-slate-300 rounded px-2">
                                        <input 
                                            type="number" 
                                            value={crateSettings.plank} 
                                            onChange={(e) => setCrateSettings({...crateSettings, plank: parseFloat(e.target.value) || 0})} 
                                            className="w-full py-1 text-center font-bold text-slate-800 outline-none"
                                        />
                                        <span className="text-[10px] text-slate-400">in</span>
                                    </div>
                                </div>
                                <div>
                                    <label className="text-[9px] text-slate-500 font-black uppercase block mb-1">Gap Size</label>
                                    <div className="flex items-center bg-white border border-slate-300 rounded px-2">
                                        <input 
                                            type="number" 
                                            value={crateSettings.gap} 
                                            onChange={(e) => setCrateSettings({...crateSettings, gap: parseFloat(e.target.value) || 0})} 
                                            className="w-full py-1 text-center font-bold text-slate-800 outline-none"
                                        />
                                        <span className="text-[10px] text-slate-400">in</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            )
        };

        // --- MAIN APP ---
        function App() {
            const [dims, setDims] = useState({ l: 40, w: 20, h: 20 });
            const [boxType, setBoxType] = useState('simple'); 
            const [crateType, setCrateType] = useState('simple'); 
            const [crateSettings, setCrateSettings] = useState({ plank: 4, gap: 4 });
            const [costPerCFT, setCostPerCFT] = useState(625);

            // Row States
            const [mainRows, setMainRows] = useState({
                top: { l: 44, w: 22, t: 1, qty: 1 },
                bottom: { l: 44, w: 22, t: 1, qty: 1 },
                sides: { l: 44, w: 20, t: 1, qty: 2 },
                kara: { l: 20, w: 20, t: 1, qty: 2 }
            });

            const [supps, setSupps] = useState({
                bottom: { size: '4x2', dim: 22, count: 2 }, 
                sides: { size: '3x1', dim: 20, count: 4 }, 
                top: { size: '3x1', dim: 22, count: 2 },
                karaHorz: { size: '3x1', dim: 20, count: 4 }, 
                karaVert: { size: '3x1', dim: 14, count: 4 } 
            });

            const [extras, setExtras] = useState([]);
            const [globalRunners, setGlobalRunners] = useState(2);

            // Derived
            const sideVertLengthSimple = parseFloat(dims.h) + (supps.bottom.dim === parseFloat(dims.w) + 2 ? (getMaxDim(supps.bottom.size) + 2) : 0);
            
            // LOGIC ENGINE
            useEffect(() => {
                const l = parseFloat(dims.l) || 0;
                const w = parseFloat(dims.w) || 0;
                const h = parseFloat(dims.h) || 0;
                const estimatedCount = estimateRunners(l);
                setGlobalRunners(estimatedCount);

                const isSimpleLogic = (boxType === 'simple' || (boxType === 'crate' && crateType === 'simple'));
                const isBottomLogic = (boxType === 'bottom' || (boxType === 'crate' && crateType === 'bottom'));

                if (isSimpleLogic) { 
                    const eL = l + 4; 
                    const eW = w + 2;
                    setMainRows({
                        top: { l: eL, w: eW, t: 1, qty: 1 },
                        bottom: { l: eL, w: eW, t: 1, qty: 1 },
                        sides: { l: eL, w: h, t: 1, qty: 2 },
                        kara: { l: w, w: h, t: 1, qty: 2 }
                    });
                    setSupps(prev => {
                        const newBottomDim = eW; 
                        const bHeight = getMaxDim(prev.bottom.size);
                        const newSideVert = h + bHeight + 2; 
                        return {
                            ...prev,
                            bottom: { ...prev.bottom, dim: newBottomDim, count: estimatedCount }, 
                            sides: { ...prev.sides, dim: newSideVert, count: estimatedCount * 2 },
                            top: { ...prev.top, dim: eW, count: estimatedCount },
                            karaHorz: { ...prev.karaHorz, dim: w },
                            karaVert: { ...prev.karaVert, dim: Math.max(0, h - 6) } 
                        };
                    });
                } else if (isBottomLogic) {
                    const bRunnerLen = l + 2;
                    const bRunnerHeight = getMaxDim(supps.bottom.size);
                    const sideMaalL = l + 2;
                    const sideRunnerLen = l + 4;
                    const karaRunnerHeight = h + bRunnerHeight;
                    const topMaalL = l + 4;
                    const topMaalW = w + 4;
                    setMainRows({
                        top: { l: topMaalL, w: topMaalW, t: 1, qty: 1 },
                        bottom: { l: l, w: w, t: 1, qty: 1 },
                        sides: { l: sideMaalL, w: h + 1, t: 1, qty: 2 },
                        kara: { l: w, w: h + 1, t: 1, qty: 2 } 
                    });
                    setSupps(prev => ({
                        ...prev,
                        bottom: { ...prev.bottom, dim: bRunnerLen, count: estimatedCount }, 
                        sides: { ...prev.sides, dim: sideRunnerLen, count: estimatedCount * 2 }, 
                        top: { ...prev.top, dim: topMaalW, count: estimatedCount }, 
                        karaHorz: { ...prev.karaHorz, dim: w }, 
                        karaVert: { ...prev.karaVert, dim: karaRunnerHeight } 
                    }));
                }
            }, [dims.l, dims.w, dims.h, boxType, crateType]);

            // Support Size Watcher
            useEffect(() => {
                const isBottomLogic = (boxType === 'bottom' || (boxType === 'crate' && crateType === 'bottom'));
                if (isBottomLogic) {
                    const h = parseFloat(dims.h) || 0;
                    const bRunnerHeight = getMaxDim(supps.bottom.size);
                    const karaRunnerHeight = h + bRunnerHeight;
                    if (supps.karaVert.dim !== karaRunnerHeight) {
                         setSupps(prev => ({...prev, karaVert: {...prev.karaVert, dim: karaRunnerHeight}}));
                    }
                } else {
                    const isBottomWidth = supps.bottom.dim === (parseFloat(dims.w) + 2);
                    const h = parseFloat(dims.h) || 0;
                    const bHeight = getMaxDim(supps.bottom.size);
                    const newSideVert = h + (isBottomWidth ? (bHeight + 2) : 0);
                    if (supps.sides.dim > h && supps.sides.dim !== newSideVert) {
                        setSupps(prev => ({...prev, sides: {...prev.sides, dim: newSideVert}}));
                    }
                }
            }, [supps.bottom.size, supps.bottom.dim, boxType, crateType, dims.h, dims.w]);

            const handleGlobalRunnerChange = (val) => {
                const count = parseInt(val) || 2;
                setGlobalRunners(count);
                setSupps(prev => ({
                    ...prev,
                    bottom: { ...prev.bottom, count: count },
                    top: { ...prev.top, count: count },
                    sides: { ...prev.sides, count: count * 2 }
                }));
            };

            const updateMainRow = (key, field, val) => {
                setMainRows(p => ({ ...p, [key]: { ...p[key], [field]: val } }));
            };

            const updateSupp = (key, field, val) => {
                setSupps(p => ({ ...p, [key]: { ...p[key], [field]: val } }));
            };

            const addExtra = () => setExtras(p => [...p, { id: Date.now(), l: 12, w: 3, t: 1, qty: 1, size: '3x1' }]);
            const removeExtra = (id) => setExtras(p => p.filter(x => x.id !== id));
            const updateExtra = (id, field, val) => {
                setExtras(p => p.map(x => x.id === id ? { ...x, [field]: val } : x));
            };

            // TOTALS
            const getRowCFT = (label, data) => {
                // If crate, calculate effective wood volume
                let effL = data.l;
                let effW = data.w;
                if (boxType === 'crate') {
                     // Pass through the same logic as the component to get effective dim for total
                     let partName = '';
                     if (label.includes('Sides')) partName = 'Sides';
                     else if (label.includes('Kara')) partName = 'Kara';
                     else if (label.includes('Top')) partName = 'Top';
                     
                     if (partName) {
                         // We need to know if it's crateSimple or crateBottom for logic
                         const specificBoxType = (crateType === 'simple') ? 'crateSimple' : 'crateBottom';
                         const res = getEffectiveCrateDims(partName, data.l, data.w, specificBoxType, crateSettings);
                         effL = res.l;
                         effW = res.w;
                     }
                }
                return calculateLineCFT(effL, effW, data.t, data.qty);
            };

            const totalBoard = getRowCFT("Top", mainRows.top) + 
                               getRowCFT("Bottom", mainRows.bottom) + 
                               getRowCFT("Sides", mainRows.sides) + 
                               getRowCFT("Kara", mainRows.kara);

            const sumSupp = (s) => {
                const d = getSizeDims(s.size);
                const feet = getPurchasedFeet(s.dim);
                return ((feet * d.w * d.t) / 144) * s.count;
            };
            
            const totalSupp = sumSupp(supps.bottom) + sumSupp(supps.sides) + sumSupp(supps.top) + 
                              sumSupp(supps.karaHorz) + sumSupp(supps.karaVert) + 
                              extras.reduce((acc,e) => acc + calculateLineCFT(e.l, e.w, e.t, e.qty), 0);
            
            const grandTotalCFT = totalBoard + totalSupp;
            const grandTotalCost = grandTotalCFT * costPerCFT;

            const [showVis, setShowVis] = useState(true);
            const canvasRef = useRef(null);
            useEffect(() => {
                if(!showVis) return;
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0, canvas.width, canvas.height);
                const L = parseFloat(dims.l);
                const W = parseFloat(dims.w);
                const H = parseFloat(dims.h);
                const max = Math.max(L, W, H);
                const scale = 50 / max; 
                const cx = canvas.width / 2; 
                const cy = canvas.height / 2 + 20; 
                const proj = (x,y,z) => ({ x: cx + (x - z) * scale * 0.866, y: cy + (x + z) * scale * 0.5 - y * scale });
                const drawPoly = (pts, col) => {
                    ctx.fillStyle = col; ctx.strokeStyle = '#78350f'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
                    pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath(); ctx.fill(); ctx.stroke();
                };
                const p0 = proj(-L/2, -H/2, W/2);
                const p1 = proj(L/2, -H/2, W/2);
                const p2 = proj(L/2, -H/2, -W/2);
                const p4 = proj(-L/2, H/2, W/2);
                const p5 = proj(L/2, H/2, W/2);
                const p6 = proj(L/2, H/2, -W/2);
                const p7 = proj(-L/2, H/2, -W/2);
                
                if (boxType === 'bottom' || (boxType === 'crate' && crateType === 'bottom')) {
                    drawPoly([p4, p5, p6, p7], '#a7f3d0'); 
                    drawPoly([p1, p2, p6, p5], '#059669'); 
                    drawPoly([p0, p1, p5, p4], '#34d399'); 
                } else {
                    drawPoly([p4, p5, p6, p7], '#fcd34d'); 
                    drawPoly([p1, p2, p6, p5], '#d97706'); 
                    drawPoly([p0, p1, p5, p4], '#fbbf24'); 
                }
            }, [showVis, dims, boxType, crateType]);

            return (
                <div className="min-h-screen pb-10">
                    <div className="bg-slate-900 text-white shadow-xl sticky top-0 z-50 border-b-4 border-amber-600">
                        <div className="max-w-2xl mx-auto p-3">
                            <div className="flex justify-between items-start mb-2">
                                <div className="flex flex-col items-start">
                                    <div className="flex items-center gap-2 mb-1">
                                        <div className="bg-amber-600 p-1.5 rounded text-white"><Icons.Box size={18} /></div>
                                        <span className="font-bold text-slate-300 text-xs uppercase tracking-widest">Smart Calc</span>
                                    </div>
                                    <div className="text-3xl font-black text-white tracking-tight">
                                        {dims.l} <span className="text-slate-500 text-xl">x</span> {dims.w} <span className="text-slate-500 text-xl">x</span> {dims.h}
                                    </div>
                                </div>
                                <div className="text-right">
                                    <div className="text-xs font-bold text-slate-400 uppercase tracking-widest mb-1">Total Cost</div>
                                    <div className="text-4xl font-black text-amber-500 leading-none">
                                        <span className="text-xl text-amber-700 mr-1">₹</span>{Math.round(grandTotalCost).toLocaleString()}
                                    </div>
                                </div>
                            </div>
                            <div className="grid grid-cols-2 gap-3 pt-2 border-t border-slate-800">
                                <div className="flex items-center bg-slate-800 rounded px-2 py-1 border border-slate-700">
                                    <span className="text-xs font-bold text-slate-400 uppercase mr-2">Rate ₹</span>
                                    <input type="number" value={costPerCFT} onChange={(e) => setCostPerCFT(parseFloat(e.target.value) || 0)} className="bg-transparent text-white font-bold text-lg w-full outline-none" />
                                </div>
                                <div className="flex items-center justify-end bg-slate-800 rounded px-2 py-1 border border-slate-700">
                                    <span className="text-white font-bold text-lg mr-1">{grandTotalCFT.toFixed(2)}</span>
                                    <span className="text-xs font-bold text-slate-400 uppercase">CFT</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="max-w-2xl mx-auto p-3 space-y-6">
                        <BoxTypeSelector 
                            type={boxType} setType={setBoxType} 
                            subType={crateType} setSubType={setCrateType}
                            crateSettings={crateSettings} setCrateSettings={setCrateSettings}
                        />

                        <div className="bg-white p-4 rounded-xl shadow-sm border-2 border-slate-200">
                            <div className="flex justify-between items-center mb-3">
                                <h2 className="text-sm font-black text-slate-500 uppercase tracking-widest">Internal Size</h2>
                                <button onClick={() => setShowVis(!showVis)} className="text-[10px] font-bold text-blue-600 bg-blue-50 px-3 py-1.5 rounded-full uppercase tracking-wide">
                                    {showVis ? 'Hide 3D' : 'Show 3D'}
                                </button>
                            </div>
                            <div className="grid grid-cols-3 gap-3">
                                {['l','w','h'].map(k => (
                                    <div key={k} className="flex flex-col">
                                        <label className="text-[10px] text-slate-500 font-black mb-1 uppercase tracking-wide bg-slate-100 w-fit px-1 rounded">{k === 'l' ? 'Length' : k === 'w' ? 'Width' : 'Height'}</label>
                                        <input type="number" value={dims[k]} onChange={(e) => setDims({...dims, [k]:e.target.value})} className="bg-slate-50 border-2 border-slate-300 rounded-lg p-3 text-3xl font-black text-slate-900 text-center focus:ring-4 focus:ring-blue-100 focus:border-blue-500 outline-none transition-all" />
                                    </div>
                                ))}
                            </div>
                        </div>

                        {showVis && (
                            <div className="bg-white rounded-xl shadow-sm border-2 border-slate-200 h-48 flex items-center justify-center overflow-hidden relative">
                                <div className="absolute top-2 left-2 text-[10px] font-bold text-slate-300 uppercase">Preview</div>
                                <canvas ref={canvasRef} width={600} height={300} className="w-full h-full" />
                            </div>
                        )}

                        <div className="bg-white rounded-xl shadow-sm border-2 border-slate-200 overflow-hidden">
                            <div className="bg-slate-100 border-b-2 border-slate-200 p-3 grid grid-cols-12 gap-2 text-[10px] font-black text-slate-500 uppercase text-center tracking-widest">
                                <div className="col-span-3 text-left pl-1">Item</div>
                                <div className="col-span-2">L</div>
                                <div className="col-span-2">W</div>
                                <div className="col-span-2">Thk</div>
                                <div className="col-span-1">Qty</div>
                                <div className="col-span-2 text-right">CFT</div>
                            </div>
                            <div className="p-2">
                                {(boxType === 'simple' || (boxType === 'crate' && crateType === 'simple')) && (
                                    <>
                                        <CalculationRow 
                                            label="Top & Bottom" 
                                            data={mainRows.top} 
                                            onChange={(f,v) => {updateMainRow('top', f, v); updateMainRow('bottom', f, v);}} 
                                            isCrate={boxType === 'crate'}
                                            crateSettings={crateSettings}
                                            boxType="crateSimple"
                                        />
                                        <CalculationRow 
                                            label="Sides" 
                                            data={mainRows.sides} 
                                            onChange={(f,v) => updateMainRow('sides', f, v)} 
                                            isCrate={boxType === 'crate'}
                                            crateSettings={crateSettings}
                                            boxType="crateSimple"
                                        />
                                        <CalculationRow 
                                            label="Kara (Ends)" 
                                            data={mainRows.kara} 
                                            onChange={(f,v) => updateMainRow('kara', f, v)} 
                                            isCrate={boxType === 'crate'}
                                            crateSettings={crateSettings}
                                            boxType="crateSimple"
                                        />
                                    </>
                                )}

                                {(boxType === 'bottom' || (boxType === 'crate' && crateType === 'bottom')) && (
                                    <>
                                        <CalculationRow 
                                            label="Bottom" 
                                            data={mainRows.bottom} 
                                            onChange={(f,v) => updateMainRow('bottom', f, v)}
                                            isCrate={false} 
                                            crateSettings={crateSettings}
                                            boxType="crateBottom"
                                        />
                                        <CalculationRow 
                                            label="Top Lid" 
                                            data={mainRows.top} 
                                            onChange={(f,v) => updateMainRow('top', f, v)} 
                                            isCrate={boxType === 'crate'}
                                            crateSettings={crateSettings}
                                            boxType="crateBottom"
                                        />
                                        <CalculationRow 
                                            label="Sides" 
                                            data={mainRows.sides} 
                                            onChange={(f,v) => updateMainRow('sides', f, v)} 
                                            isCrate={boxType === 'crate'}
                                            crateSettings={crateSettings}
                                            boxType="crateBottom"
                                        />
                                        <CalculationRow 
                                            label="Kara (Ends)" 
                                            data={mainRows.kara} 
                                            onChange={(f,v) => updateMainRow('kara', f, v)} 
                                            isCrate={boxType === 'crate'}
                                            crateSettings={crateSettings}
                                            boxType="crateBottom"
                                        />
                                    </>
                                )}
                            </div>
                            <div className="bg-amber-50 p-3 flex justify-between items-center border-t-2 border-amber-100">
                                <span className="font-black text-sm text-amber-900 uppercase tracking-wide">Box Board Total</span>
                                <span className="font-black text-xl text-amber-700">{totalBoard.toFixed(3)}</span>
                            </div>
                        </div>

                        <div className="space-y-4 pt-2">
                            <div className="flex items-center justify-between bg-slate-800 text-white p-4 rounded-xl shadow-lg border-l-4 border-blue-500">
                                <div className="flex items-center gap-3">
                                    <Icons.Settings size={24} className="text-blue-400"/>
                                    <div>
                                        <h3 className="font-black text-lg uppercase tracking-wide">Runners</h3>
                                        <p className="text-xs text-slate-400 font-bold">Auto-Estimated: {estimateRunners(dims.l)}</p>
                                    </div>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-xs font-bold uppercase text-slate-300">Set Global:</span>
                                    <div className="flex items-center bg-white rounded-lg p-1">
                                        <button onClick={() => handleGlobalRunnerChange(globalRunners - 1)} className="w-10 h-10 flex items-center justify-center bg-slate-100 rounded hover:bg-slate-200 text-slate-800 font-bold text-xl">-</button>
                                        <span className="w-12 text-center text-2xl font-black text-slate-900">{globalRunners}</span>
                                        <button onClick={() => handleGlobalRunnerChange(globalRunners + 1)} className="w-10 h-10 flex items-center justify-center bg-blue-600 rounded text-white font-bold text-xl hover:bg-blue-700">+</button>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <SupportCard 
                                    label="Bottom Supports"
                                    sizeOptions={['4x3', '3x2', '4x2', '4x1.5', '4x1', '3x1']}
                                    dimOptions={[
                                        {val: mainRows.bottom.w, label: `${mainRows.bottom.w}" (Width)`},
                                        {val: supps.bottom.dim, label: `${supps.bottom.dim}" (Calc Length)`}
                                    ]}
                                    settings={supps.bottom}
                                    onUpdate={(f,v) => updateSupp('bottom', f, v)}
                                />

                                <SupportCard 
                                    label="Side Supports"
                                    sizeOptions={['3x1', '4x1', '3x1.5', '4x1.5']}
                                    dimOptions={[
                                        {val: supps.sides.dim, label: `${supps.sides.dim}" (Calc)`},
                                        {val: mainRows.sides.l, label: `${mainRows.sides.l}" (Panel Len)`}
                                    ]}
                                    settings={supps.sides}
                                    onUpdate={(f,v) => updateSupp('sides', f, v)}
                                />

                                <SupportCard 
                                    label="Top Lid Supports"
                                    sizeOptions={['3x1', '4x1', '3x1.5']}
                                    dimOptions={[
                                        {val: mainRows.top.w, label: `${mainRows.top.w}" (Width)`},
                                        {val: mainRows.top.l, label: `${mainRows.top.l}" (Length)`}
                                    ]}
                                    settings={supps.top}
                                    onUpdate={(f,v) => updateSupp('top', f, v)}
                                />

                                <SupportCard 
                                    label="Kara Horizontal"
                                    sizeOptions={['3x1', '4x1']}
                                    dimOptions={[{val: mainRows.kara.l, label: `${mainRows.kara.l}" (Width)`}]}
                                    settings={supps.karaHorz}
                                    onUpdate={(f,v) => updateSupp('karaHorz', f, v)}
                                />
                                <SupportCard 
                                    label="Kara Vertical (Gap)"
                                    sizeOptions={['3x1', '4x1']}
                                    dimOptions={[
                                        {val: supps.karaVert.dim, label: `${supps.karaVert.dim}" (Calc H)`}
                                    ]}
                                    settings={supps.karaVert}
                                    onUpdate={(f,v) => updateSupp('karaVert', f, v)}
                                />
                            </div>

                            {extras.map((ex) => (
                                <div key={ex.id} className="rounded-xl shadow-md border-2 border-blue-200 bg-white overflow-hidden mb-3">
                                    <div className="p-3 border-b border-blue-100 flex justify-between items-center bg-blue-50">
                                        <span className="text-sm font-black text-blue-700 uppercase tracking-wide">Extra Support</span>
                                        <div className="flex items-center gap-3">
                                            <span className="font-mono font-black text-xl text-amber-700">{calculateLineCFT(ex.l, ex.w, ex.t, ex.qty).toFixed(2)}</span>
                                            <button onClick={() => removeExtra(ex.id)} className="text-red-500 bg-white p-2 rounded-lg border border-red-200 hover:bg-red-50"><Icons.Trash size={20}/></button>
                                        </div>
                                    </div>
                                    <div className="p-4 space-y-3">
                                        <div className="grid grid-cols-5 gap-2">
                                            <div className="col-span-3">
                                                <label className="text-xs text-slate-400 font-bold uppercase mb-1 block">Size</label>
                                                <select 
                                                    className="w-full border-2 border-slate-300 rounded-lg p-2 font-bold text-slate-800"
                                                    value={ex.size}
                                                    onChange={(e) => {
                                                        const s = getSizeDims(e.target.value);
                                                        updateExtra(ex.id, 'size', e.target.value);
                                                        updateExtra(ex.id, 'w', s.w); updateExtra(ex.id, 't', s.t);
                                                    }}
                                                >
                                                    <option value="Custom">Custom</option>
                                                    <option value="3x1">3 x 1</option>
                                                    <option value="4x1">4 x 1</option>
                                                </select>
                                            </div>
                                            <div className="col-span-1"><label className="text-xs text-slate-400 font-bold uppercase mb-1 block">W</label><NumberInput value={ex.w} onChange={(v)=>updateExtra(ex.id,'w',v)} /></div>
                                            <div className="col-span-1"><label className="text-xs text-slate-400 font-bold uppercase mb-1 block">T</label><NumberInput value={ex.t} onChange={(v)=>updateExtra(ex.id,'t',v)} step={0.25} /></div>
                                        </div>
                                        <div className="grid grid-cols-2 gap-3">
                                            <div><label className="text-xs text-slate-400 font-bold uppercase mb-1 block">Length</label><NumberInput value={ex.l} onChange={(v)=>updateExtra(ex.id,'l',v)} /></div>
                                            <div><label className="text-xs text-slate-400 font-bold uppercase mb-1 block">Qty</label><NumberInput value={ex.qty} onChange={(v)=>updateExtra(ex.id,'qty',v)} step={1} className="bg-blue-50" /></div>
                                        </div>
                                    </div>
                                </div>
                            ))}

                            <button onClick={addExtra} className="w-full py-4 bg-white border-2 border-dashed border-blue-300 text-blue-600 rounded-xl font-black hover:bg-blue-50 mt-2 flex justify-center items-center gap-2 shadow-sm uppercase tracking-wide text-lg transition-colors">
                                <Icons.Plus size={24}/> Add Extra Support
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
