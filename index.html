<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ambica Wooden Works - Smart CFT Calculator</title>
    
    <!-- 1. STYLE ENGINE (Tailwind CSS) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. THE BRAIN (React & Babel) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 3. 3D ENGINE (Three.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700;900&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        body { 
            overscroll-behavior-y: none; 
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        .font-brand { font-family: 'Roboto Slab', serif; }
        
        /* High Contrast Inputs */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; margin: 0; 
        }
        
        .wood-pattern {
            background-color: #fcecdb;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h40v40H0V0zm20 20h20v20H20V20zM0 20h20v20H0V20z' fill='%23d97706' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E");
        }

        .sticky-bar-enter { transform: translateY(-100%); opacity: 0; }
        .sticky-bar-active { transform: translateY(0); opacity: 1; transition: all 0.3s ease-in-out; }
        .sticky-bar-exit { transform: translateY(-100%); opacity: 0; transition: all 0.3s ease-in-out; }
        
        select::-ms-expand { display: none; }
    </style>
</head>
<body class="bg-amber-50 text-slate-900 font-sans pb-40 select-none wood-pattern">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- ICONS ---
        const Icon = ({ path, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
        );

        const Icons = {
            Box: (p) => <Icon {...p} path={<><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></>} />,
            Plus: (p) => <Icon {...p} path={<><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></>} />,
            Trash: (p) => <Icon {...p} path={<><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></>} />,
            Rotate: (p) => <Icon {...p} path={<><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/></>} />,
        };

        // --- HELPERS ---
        const getPurchasedFeet = (inches) => {
            const feet = inches / 12;
            const whole = Math.floor(feet);
            const fraction = feet - whole;
            if (fraction === 0) return whole;
            if (fraction <= 0.5001) return whole + 0.5;
            return whole + 1.0;
        };

        const calculateLineCFT = (l, w, t, qty) => {
            const feet = getPurchasedFeet(l);
            return ((feet * w * t) / 144) * qty;
        };

        const getSizeDims = (sizeStr) => {
            const map = {
                '3x1': {w:3, t:1}, '4x1': {w:4, t:1}, 
                '3x1.5': {w:3, t:1.5}, '4x1.5': {w:4, t:1.5},
                '3x2': {w:3, t:2}, '4x2': {w:4, t:2}, 
                '4x3': {w:4, t:3}, '4x4': {w:4, t:4}
            };
            return map[sizeStr] || {w:3, t:1};
        };

        const getMaxDim = (sizeStr) => {
            if(!sizeStr) return 0;
            const dims = getSizeDims(sizeStr);
            return Math.max(dims.w, dims.t); 
        };

        const calculateCrateEffectiveLength = (span, plankWidth, gap) => {
            if (!span || span <= 0) return 0;
            const unit = plankWidth + gap;
            const planks = Math.ceil(span / unit);
            return planks * plankWidth;
        };

        const getEffectiveCrateDims = (partName, originalL, originalW, boxType, crateSettings) => {
            const { plank, gap } = crateSettings;
            if (!plank || !gap) return { l: originalL, w: originalW, note: null };

            let result = { l: originalL, w: originalW, note: null };

            if (partName === 'Sides') {
                const effH = calculateCrateEffectiveLength(originalW, plank, gap);
                result.w = effH;
                result.note = 'Height adjusted for gaps';
            } else if (partName === 'Kara') {
                const effW = calculateCrateEffectiveLength(originalL, plank, gap);
                const effH = calculateCrateEffectiveLength(originalW, plank, gap);
                result.l = effW;
                result.w = effH;
                result.note = 'Width & Height adjusted';
            } else if (partName === 'Top') {
                if (boxType === 'crateBottom') {
                    const effL = calculateCrateEffectiveLength(originalL, plank, gap);
                    const effW = calculateCrateEffectiveLength(originalW, plank, gap);
                    result.l = effL;
                    result.w = effW;
                    result.note = 'Length & Width adjusted';
                }
            }

            return result;
        };

        // --- 3D VISUALIZER ---
        const ThreeScene = ({ dims, boxType, crateType, mainRows, supps, runnerConfig }) => {
            const mountRef = useRef(null);
            
            useEffect(() => {
                if (!mountRef.current) return;
                const w = mountRef.current.clientWidth;
                const h = mountRef.current.clientHeight;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xfff8ef); 

                const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
                camera.position.set(60, 50, 80);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(w, h);
                renderer.shadowMap.enabled = true;
                mountRef.current.innerHTML = '';
                mountRef.current.appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
                dirLight.position.set(50, 60, 50);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                // Materials
                const woodMat = new THREE.MeshStandardMaterial({ color: 0xfcd34d, roughness: 0.8 }); 
                const woodMatSide = new THREE.MeshStandardMaterial({ color: 0xf59e0b, roughness: 0.8 });
                const woodMatDark = new THREE.MeshStandardMaterial({ color: 0x78350f, roughness: 0.9 }); 

                const createBox = (w, h, d, colorMat, x, y, z) => {
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mesh = new THREE.Mesh(geo, colorMat);
                    mesh.position.set(x, y, z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    return mesh;
                };

                const group = new THREE.Group();
                scene.add(group);

                // --- VISUALIZATION LOGIC ---
                const THK = 1; 
                const isBottomType = (boxType === 'bottom' || (boxType === 'crate' && crateType === 'bottom'));
                
                // --- 1. BOTTOM RUNNERS ---
                const bSize = getSizeDims(supps.bottom.size);
                const bH = bSize.w; 
                const bW = bSize.t; 
                const bLen = supps.bottom.dim;
                const bCount = supps.bottom.count;
                
                let runnerPositions = [];

                if(bCount > 0) {
                    if(isBottomType) {
                        // BOTTOM TYPE: Horizontal (Length-wise).
                        const spreadW = mainRows.bottom.w; 
                        
                        for(let i=0; i<bCount; i++) {
                            let zPos;
                            if (bCount === 1) zPos = 0;
                            else {
                                const maxOffset = (spreadW/2) - (bW/2);
                                const pct = i / (bCount - 1);
                                zPos = -maxOffset + (pct * 2 * maxOffset);
                            }
                            
                            runnerPositions.push(zPos); 
                            group.add(createBox(bLen, bH, bW, woodMatDark, 0, bH/2, zPos));
                        }
                    } else {
                        // SIMPLE TYPE
                        if(runnerConfig.bottomDir === 'width') {
                            // Standard: Width-wise, spaced along Length
                            const spreadL = mainRows.bottom.l; 
                            const stepX = spreadL / (bCount + 1);
                            for(let i=1; i<=bCount; i++) {
                                const xPos = -spreadL/2 + (i * stepX);
                                runnerPositions.push(xPos);
                                group.add(createBox(bW, bH, bLen, woodMatDark, xPos, bH/2, 0));
                            }
                        } else {
                            // *** FIX 1: Horizontal Override - NOW POPULATES runnerPositions ***
                            const spreadW = mainRows.bottom.w; 
                            const stepZ = spreadW / (bCount + 1);
                            for(let i=1; i<=bCount; i++) {
                                const zPos = -spreadW/2 + (i * stepZ);
                                runnerPositions.push(zPos); // NOW STORES Z POSITIONS
                                group.add(createBox(bLen, bH, bW, woodMatDark, 0, bH/2, zPos));
                            }
                        }
                    }
                }

                const baseY = bH; 

                // --- 2. BOTTOM PANEL ---
                const botL = mainRows.bottom.l;
                const botW = mainRows.bottom.w;
                group.add(createBox(botL, THK, botW, woodMat, 0, baseY + THK/2, 0));
                
                const floorLevel = baseY + THK;

                // --- 3. SIDES ---
                const sL = mainRows.sides.l;
                const sH = mainRows.sides.w;
                let sideY, sideZ_offset;
                
                if (isBottomType) {
                    sideY = baseY + sH/2;
                    sideZ_offset = (mainRows.bottom.w / 2) + (THK/2);
                } else {
                    sideY = floorLevel + sH/2;
                    sideZ_offset = (botW / 2) - (THK/2); 
                }

                group.add(createBox(sL, sH, THK, woodMatSide, 0, sideY, sideZ_offset));
                group.add(createBox(sL, sH, THK, woodMatSide, 0, sideY, -sideZ_offset));

                // --- 4. KARA (ENDS) ---
                const kL = mainRows.kara.l;
                const kH = mainRows.kara.w;
                const kThk = THK;

                let karaY, karaX_offset;

                if (isBottomType) {
                    karaY = baseY + kH/2;
                    karaX_offset = (mainRows.bottom.l / 2) + (kThk/2); 
                } else {
                    karaY = floorLevel + kH/2;
                    karaX_offset = (parseFloat(dims.l) / 2) + (kThk/2);
                }

                group.add(createBox(kThk, kH, kL, woodMatSide, karaX_offset, karaY, 0));
                group.add(createBox(kThk, kH, kL, woodMatSide, -karaX_offset, karaY, 0));

                // --- 5. SIDE RUNNERS ---
                const srLen = supps.sides.dim;
                const srCount = Math.round(supps.sides.count / 2);
                
                const drawSideRunners = (sideMultiplier) => {
                    const zPosPanel = sideMultiplier * (sideZ_offset + THK + 0.5);

                    if (isBottomType || runnerConfig.sideDir === 'horizontal') {
                        // HORIZONTAL
                        // *** FIX 4: Bottom Type - One runner at top, rest distributed ***
                        if (isBottomType && srCount > 0) {
                            // First runner at the very top
                            const topY = baseY + sH - 1.5; // Near top edge (1.5 = half thickness of 3")
                            group.add(createBox(srLen, 3, 1, woodMatDark, 0, topY, zPosPanel));
                            
                            // Remaining runners distributed in the middle/lower section
                            if (srCount > 1) {
                                const remainingSpace = sH - 3; // Space below the top runner
                                const step = remainingSpace / srCount;
                                for(let i=1; i<srCount; i++) {
                                    const yPos = baseY + (i * step);
                                    group.add(createBox(srLen, 3, 1, woodMatDark, 0, yPos, zPosPanel));
                                }
                            }
                        } else {
                            // Simple type horizontal (original logic)
                            const stepY = sH / (srCount + 1);
                            for(let i=1; i<=srCount; i++) {
                                const yPos = (isBottomType ? baseY : floorLevel) + (i * stepY);
                                group.add(createBox(srLen, 3, 1, woodMatDark, 0, yPos, zPosPanel));
                            }
                        }
                    } else {
                        // VERTICAL (Simple Standard) - ALIGNED with Bottom Runners
                        let positions = [];
                        if (runnerConfig.bottomDir === 'width' && runnerPositions.length > 0) {
                            positions = runnerPositions;
                        } else {
                            const totalL = mainRows.sides.l;
                            const step = totalL / (srCount + 1);
                            for(let i=1; i<=srCount; i++) positions.push(-totalL/2 + i*step);
                        }

                        const vCenterY = srLen / 2; 
                        
                        positions.forEach(xPos => {
                             group.add(createBox(3, srLen, 1, woodMatDark, xPos, vCenterY, zPosPanel));
                        });
                    }
                };
                
                if (supps.sides.count > 0) {
                    drawSideRunners(1);
                    drawSideRunners(-1);
                }

                // --- 6. KARA RUNNERS (SQUARE FRAME LOGIC) ---
                if (isBottomType) {
                    // Bottom Type: Vertical Posts
                    const kVertLen = supps.karaVert.dim;
                    const kVertSize = getSizeDims(supps.karaVert.size);
                    const kVertW = kVertSize.w; // Width of vertical post (e.g., 3 or 4)
                    const kV_Y = baseY + (kVertLen / 2); 
                    
                    [1, -1].forEach(dirX => { 
                         const xPos = dirX * (karaX_offset + kThk + 1.5); 
                         
                         if(runnerPositions.length > 0) {
                             runnerPositions.forEach(zPos => {
                                 group.add(createBox(kVertW, kVertLen, kVertW, woodMatDark, xPos, kV_Y, zPos));
                             });
                         } else {
                             const kPostZ = (kL/2) - 1.5;
                             group.add(createBox(kVertW, kVertLen, kVertW, woodMatDark, xPos, kV_Y, kPostZ));
                             group.add(createBox(kVertW, kVertLen, kVertW, woodMatDark, xPos, kV_Y, -kPostZ));
                         }
                    });
                } else {
                    // *** FIX 2: SIMPLE TYPE - KARA FRAME MORE VISIBLE ***
                    const kHorzLen = supps.karaHorz.dim;
                    const kVertLen = supps.karaVert.dim;
                    const suppW = getSizeDims(supps.karaHorz.size).w;
                    const frameThickness = 2.5; // Increased from 1 to 2.5 for visibility

                    const kY_Top = floorLevel + kH - (suppW/2);
                    const kY_Bot = floorLevel + (suppW/2);
                    const kY_Mid = floorLevel + (kH/2);

                    const kZ_Left = (kL/2) - (suppW/2);
                    const kZ_Right = -((kL/2) - (suppW/2));

                    [1, -1].forEach(dirX => {
                        const xPos = dirX * (karaX_offset - kThk - 1.5); // Moved slightly outward
                        
                        // 1. Top Horizontal
                        group.add(createBox(frameThickness, suppW, kHorzLen, woodMatDark, xPos, kY_Top, 0));
                        // 2. Bottom Horizontal
                        group.add(createBox(frameThickness, suppW, kHorzLen, woodMatDark, xPos, kY_Bot, 0));
                        
                        // 3. Vertical Left & Right
                        if (kVertLen > 0) {
                            group.add(createBox(frameThickness, kVertLen, suppW, woodMatDark, xPos, kY_Mid, kZ_Left));
                            group.add(createBox(frameThickness, kVertLen, suppW, woodMatDark, xPos, kY_Mid, kZ_Right));
                        }
                    });
                }

                // --- 7. TOP LID ---
                const tL = mainRows.top.l;
                const tW = mainRows.top.w;
                const topY = (isBottomType ? baseY : floorLevel) + sH + THK/2;
                group.add(createBox(tL, THK, tW, woodMat, 0, topY, 0));

                // --- 8. TOP LID RUNNERS ---
                if (runnerPositions.length > 0) {
                     const trH = 1.5; // Increased thickness for visibility
                     const trY = topY - (THK/2) - (trH/2);
                     
                     if (isBottomType) {
                         // *** FIX 3: BOTTOM TYPE - Length-wise runners connecting kara posts ***
                         const trW = 3; 
                         const trLen = tL;
                         
                         // Calculate the positions where kara vertical posts are
                         const karaPostX_Left = -(karaX_offset + kThk + 1.5);
                         const karaPostX_Right = (karaX_offset + kThk + 1.5);

                         runnerPositions.forEach(zPos => {
                             // Create runners that span from left kara post to right kara post
                             // Position them at the Z positions of the bottom runners
                             group.add(createBox(trLen, trH, trW, woodMatDark, 0, trY, zPos));
                         });

                     } else {
                         // SIMPLE TYPE: Run Width-wise (Z), aligned with X positions
                         const trLen = tW;
                         const sideSize = getSizeDims(supps.sides.size);
                         const trW = sideSize.w; 

                         runnerPositions.forEach(xPos => {
                             group.add(createBox(trW, trH, trLen, woodMatDark, xPos, trY, 0));
                         });
                     }
                }

                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                return () => {
                    if(mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    renderer.dispose();
                };
            }, [dims, boxType, crateType, mainRows, supps, runnerConfig]);

            return <div ref={mountRef} style={{ width: '100%', height: '100%' }} />;
        };

        // --- COMPONENTS ---

        const NumberInput = ({ value, onChange, className = "", step = 0.125 }) => (
            <input 
                type="number" 
                value={value} 
                onChange={(e) => { const val = e.target.value; onChange(val === '' ? '' : parseFloat(val)); }} 
                step={step}
                className={`w-full bg-white border-2 border-slate-900 rounded-lg px-2 py-3 text-center font-mono font-black text-xl text-black focus:ring-4 focus:ring-amber-400 focus:border-amber-700 outline-none transition-all shadow-sm ${className}`}
            />
        );

        const CalculationRow = ({ label, data, onChange, isCrate, crateSettings, boxType }) => {
            let effL = data.l || 0;
            let effW = data.w || 0;
            let note = null;

            if (isCrate) {
                let partName = '';
                if (label.includes('Sides')) partName = 'Sides';
                else if (label.includes('Kara')) partName = 'Kara';
                else if (label.includes('Top')) partName = 'Top';

                if (partName) {
                    const res = getEffectiveCrateDims(partName, data.l, data.w, boxType, crateSettings);
                    effL = res.l;
                    effW = res.w;
                    note = res.note;
                }
            }

            const cft = calculateLineCFT(effL, effW, data.t || 0, data.qty || 0);

            return (
                <div className={`grid grid-cols-12 gap-2 items-center border-b-2 border-slate-300 py-4 last:border-0 ${isCrate && note ? 'bg-amber-100/50' : ''}`}>
                    <div className="col-span-3">
                        <div className="text-sm font-black text-black uppercase tracking-tight leading-tight">{label}</div>
                        {isCrate && note && <div className="text-[10px] font-bold text-amber-800 uppercase tracking-wider bg-amber-200 inline-block px-1 rounded mt-1">GAP ACTIVE</div>}
                    </div>
                    <div className="col-span-2 relative">
                        <NumberInput value={data.l} onChange={(v) => onChange('l', v)} className="text-lg py-2" />
                        {isCrate && note && note.includes("Length") && <div className="absolute -bottom-4 left-0 w-full text-[9px] text-center font-bold text-amber-800 bg-amber-100 rounded px-1">Wood: {effL}</div>}
                    </div>
                    <div className="col-span-2 relative">
                        <NumberInput value={data.w} onChange={(v) => onChange('w', v)} className="text-lg py-2" />
                        {isCrate && note && (note.includes("Height") || note.includes("Width")) && <div className="absolute -bottom-4 left-0 w-full text-[9px] text-center font-bold text-amber-800 bg-amber-100 rounded px-1">Wood: {effW}</div>}
                    </div>
                    <div className="col-span-2"><NumberInput value={data.t} onChange={(v) => onChange('t', v)} step={0.25} className="text-lg py-2" /></div>
                    <div className="col-span-1"><NumberInput value={data.qty} onChange={(v) => onChange('qty', v)} className="px-0 text-lg py-2" step={1} /></div>
                    <div className="col-span-2 text-right font-mono font-black text-amber-800 text-lg">{cft.toFixed(2)}</div>
                </div>
            );
        };

        const SupportCard = ({ label, sizeOptions, dimValue, settings, onUpdate, colorClass="bg-white", configKey, runnerConfig, onConfigChange, fixedDir }) => {
            const sDims = getSizeDims(settings.size);
            const feet = getPurchasedFeet(settings.dim);
            const cft = ((feet * sDims.w * sDims.t) / 144) * settings.count;

            return (
                <div className={`rounded-xl shadow-[4px_4px_0px_0px_rgba(0,0,0,0.2)] border-2 border-slate-900 overflow-hidden ${colorClass}`}>
                    <div className="p-3 border-b-2 border-slate-900 flex justify-between items-center bg-slate-200">
                        <span className="text-sm font-black text-black uppercase tracking-wide">{label}</span>
                        <span className="font-mono font-black text-xl text-amber-800">{cft.toFixed(2)} <span className="text-xs text-black">CFT</span></span>
                    </div>
                    <div className="p-4 space-y-4">
                        <div className="grid grid-cols-2 gap-4">
                             <div>
                                <label className="text-xs text-black font-black mb-1 uppercase block tracking-wider">Size</label>
                                <select 
                                    value={settings.size} 
                                    onChange={(e) => onUpdate('size', e.target.value)}
                                    className="w-full bg-white border-2 border-slate-900 rounded-lg py-2 px-2 text-xl font-black text-black focus:ring-4 focus:ring-amber-400 outline-none appearance-none"
                                >
                                    {sizeOptions.map(s => <option key={s} value={s}>{s}</option>)}
                                </select>
                            </div>
                             <div>
                                <label className="text-xs text-black font-black mb-1 uppercase block tracking-wider">Length</label>
                                <div className="w-full bg-slate-100 border-2 border-slate-400 rounded-lg py-2 px-2 text-xl font-black text-slate-600 text-center">
                                    {settings.dim}"
                                </div>
                            </div>
                        </div>

                        {!fixedDir && configKey && (
                            <div className="flex bg-slate-100 p-1 rounded-lg border border-slate-300">
                                <button 
                                    onClick={() => onConfigChange(configKey, configKey === 'bottomDir' ? 'width' : 'vertical')}
                                    className={`flex-1 py-1 text-xs font-black uppercase rounded ${runnerConfig[configKey] === (configKey === 'bottomDir' ? 'width' : 'vertical') ? 'bg-white shadow text-black' : 'text-slate-400'}`}
                                >
                                    {configKey === 'bottomDir' ? 'Width-wise' : 'Vertical'}
                                </button>
                                <button 
                                    onClick={() => onConfigChange(configKey, configKey === 'bottomDir' ? 'length' : 'horizontal')}
                                    className={`flex-1 py-1 text-xs font-black uppercase rounded ${runnerConfig[configKey] === (configKey === 'bottomDir' ? 'length' : 'horizontal') ? 'bg-white shadow text-black' : 'text-slate-400'}`}
                                >
                                    Horizontal
                                </button>
                            </div>
                        )}
                        {fixedDir && (
                             <div className="text-[10px] text-center font-black uppercase text-slate-400 bg-slate-100 py-1 rounded border border-slate-200">
                                Fixed: {fixedDir}
                            </div>
                        )}

                        <div className="flex items-center gap-4">
                             <div className="flex-grow">
                                <label className="text-xs text-black font-black mb-1 uppercase block tracking-wider">Quantity</label>
                                <div className="flex items-center gap-2">
                                    <button onClick={() => onUpdate('count', Math.max(0, settings.count - 1))} className="bg-slate-200 w-12 h-12 flex items-center justify-center rounded-lg border-2 border-slate-900 font-bold hover:bg-slate-300 active:bg-slate-400 text-xl">-</button>
                                    <NumberInput value={settings.count} onChange={(v) => onUpdate('count', v)} step={1} className="py-2 text-2xl font-black bg-white" />
                                    <button onClick={() => onUpdate('count', settings.count + 1)} className="bg-slate-200 w-12 h-12 flex items-center justify-center rounded-lg border-2 border-slate-900 font-bold hover:bg-slate-300 active:bg-slate-400 text-xl">+</button>
                                </div>
                            </div>
                            <div className="w-24">
                                <label className="text-xs text-black font-black mb-1 uppercase block text-right tracking-wider">Purchase</label>
                                <div className="bg-amber-100 border-2 border-amber-800 rounded-lg py-2 px-2 text-right">
                                    <span className="text-2xl font-black text-amber-900">{feet.toFixed(1)}</span>
                                    <span className="text-xs text-black ml-1 font-bold">ft</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const BoxTypeSelector = ({ type, setType, subType, setSubType, crateSettings, setCrateSettings }) => {
            return (
                <div className="bg-white p-4 rounded-xl shadow-[4px_4px_0px_0px_rgba(0,0,0,0.2)] border-2 border-black mb-6">
                    <label className="text-sm text-black font-black uppercase tracking-wide block mb-3 border-b-2 border-slate-100 pb-2">Select Box Type</label>
                    <div className="grid grid-cols-3 gap-3">
                        {['simple', 'bottom', 'crate'].map(t => (
                            <button 
                                key={t}
                                onClick={() => setType(t)}
                                className={`py-4 px-2 rounded-xl text-base font-black uppercase tracking-wider transition-all border-2 ${
                                    type === t 
                                    ? 'bg-amber-600 border-black text-white shadow-inner transform scale-105' 
                                    : 'bg-white border-slate-300 text-slate-900 hover:border-black hover:bg-slate-100'
                                }`}
                            >
                                {t}
                            </button>
                        ))}
                    </div>
                    
                    {type === 'crate' && (
                        <div className="mt-4 pt-4 border-t-2 border-slate-200 animate-fade-in bg-amber-50 -mx-4 px-4 pb-4 rounded-b-lg">
                            <label className="text-xs text-amber-900 font-black uppercase mb-2 block">Crate Configuration</label>
                            <div className="grid grid-cols-2 gap-3 mb-4">
                                <button 
                                    onClick={() => setSubType('simple')}
                                    className={`py-3 text-sm font-black uppercase rounded-lg border-2 shadow-sm ${subType === 'simple' ? 'bg-blue-600 border-black text-white' : 'bg-white border-slate-400 text-slate-800'}`}
                                >
                                    Simple Crate
                                </button>
                                <button 
                                    onClick={() => setSubType('bottom')}
                                    className={`py-3 text-sm font-black uppercase rounded-lg border-2 shadow-sm ${subType === 'bottom' ? 'bg-blue-600 border-black text-white' : 'bg-white border-slate-400 text-slate-800'}`}
                                >
                                    Bottom Crate
                                </button>
                            </div>

                            <div className="grid grid-cols-2 gap-4 bg-white p-4 rounded-xl border-2 border-amber-200 shadow-sm">
                                <div>
                                    <label className="text-[11px] text-amber-900 font-black uppercase block mb-1">Plank Width (Inch)</label>
                                    <div className="flex items-center bg-white border-2 border-amber-300 rounded-lg overflow-hidden">
                                        <input 
                                            type="number" 
                                            value={crateSettings.plank} 
                                            onChange={(e) => setCrateSettings({...crateSettings, plank: parseFloat(e.target.value) || 0})} 
                                            className="w-full py-2 text-center font-black text-xl text-black outline-none"
                                        />
                                    </div>
                                </div>
                                <div>
                                    <label className="text-[11px] text-amber-900 font-black uppercase block mb-1">Gap Size (Inch)</label>
                                    <div className="flex items-center bg-white border-2 border-amber-300 rounded-lg overflow-hidden">
                                        <input 
                                            type="number" 
                                            value={crateSettings.gap} 
                                            onChange={(e) => setCrateSettings({...crateSettings, gap: parseFloat(e.target.value) || 0})} 
                                            className="w-full py-2 text-center font-black text-xl text-black outline-none"
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            )
        };

        function App() {
            const [dims, setDims] = useState({ l: 40, w: 20, h: 20 });
            const [boxType, setBoxType] = useState('simple'); 
            const [crateType, setCrateType] = useState('simple'); 
            const [crateSettings, setCrateSettings] = useState({ plank: 4, gap: 4 });
            const [costPerCFT, setCostPerCFT] = useState(625);
            const [showStickyStats, setShowStickyStats] = useState(false);
            const headerRef = useRef(null);

            const [runnerConfig, setRunnerConfig] = useState({
                bottomDir: 'width', 
                sideDir: 'vertical' 
            });

            const [mainRows, setMainRows] = useState({
                top: { l: 44, w: 22, t: 1, qty: 1 },
                bottom: { l: 44, w: 22, t: 1, qty: 1 },
                sides: { l: 44, w: 20, t: 1, qty: 2 },
                kara: { l: 20, w: 20, t: 1, qty: 2 }
            });

            const [supps, setSupps] = useState({
                bottom: { size: '4x2', dim: 22, count: 2 }, 
                sides: { size: '3x1', dim: 20, count: 4 }, 
                top: { size: '3x1', dim: 22, count: 2 },
                karaHorz: { size: '3x1', dim: 20, count: 4 }, 
                karaVert: { size: '3x1', dim: 14, count: 4 } 
            });

            const [extras, setExtras] = useState([]);
            const [globalRunners, setGlobalRunners] = useState(2);
            
            useEffect(() => {
                const handleScroll = () => {
                    if (headerRef.current) {
                        if (window.scrollY > 280) setShowStickyStats(true);
                        else setShowStickyStats(false);
                    }
                };
                window.addEventListener('scroll', handleScroll);
                return () => window.removeEventListener('scroll', handleScroll);
            }, []);

            useEffect(() => {
                const l = parseFloat(dims.l) || 0;
                const w = parseFloat(dims.w) || 0;
                const h = parseFloat(dims.h) || 0;
                
                const isBottomLogic = (boxType === 'bottom' || (boxType === 'crate' && crateType === 'bottom'));
                const isSimpleLogic = !isBottomLogic;
                const estimatedCount = globalRunners; 

                if (isSimpleLogic) {
                    const baseL = l + 4;
                    const baseW = w + 2;

                    setMainRows({
                        top: { l: baseL, w: baseW, t: 1, qty: 1 },
                        bottom: { l: baseL, w: baseW, t: 1, qty: 1 },
                        sides: { l: baseL, w: h, t: 1, qty: 2 }, 
                        kara: { l: w, w: h, t: 1, qty: 2 }       
                    });

                    setSupps(prev => {
                        const bSize = getMaxDim(prev.bottom.size);
                        let bRunLen;
                        if (runnerConfig.bottomDir === 'width') bRunLen = baseW; 
                        else bRunLen = baseL; 

                        let sRunLen;
                        if (runnerConfig.sideDir === 'horizontal') {
                            sRunLen = baseL; 
                        } else {
                            const bottomAdd = (runnerConfig.bottomDir === 'width') ? bSize : 0;
                            sRunLen = h + bottomAdd + 2;
                        }

                        const kRunLen = w;
                        const kSuppWidth = getSizeDims(prev.karaHorz.size).w;
                        const kVertLen = Math.max(0, h - (2 * kSuppWidth));

                        return {
                            ...prev,
                            bottom: { ...prev.bottom, dim: bRunLen, count: estimatedCount },
                            sides: { ...prev.sides, dim: sRunLen, count: estimatedCount * 2 },
                            top: { ...prev.top, dim: baseW, count: estimatedCount },
                            karaHorz: { ...prev.karaHorz, dim: kRunLen, count: 4 },
                            karaVert: { ...prev.karaVert, dim: kVertLen, count: 4 }
                        };
                    });

                } else {
                    const bRunLen = l + 2;
                    const sidePanelL = l + 2;
                    const sidePanelH = h + 1;
                    const sideRunLen = l + 4; 
                    const topL = l + 4;
                    const topW = w + 4;
                    
                    setMainRows({
                        top: { l: topL, w: topW, t: 1, qty: 1 },
                        bottom: { l: l, w: w, t: 1, qty: 1 }, 
                        sides: { l: sidePanelL, w: sidePanelH, t: 1, qty: 2 },
                        kara: { l: w, w: h + 1, t: 1, qty: 2 } 
                    });

                    setSupps(prev => {
                        const bSize = getMaxDim(prev.bottom.size);
                        const kVertLen = h + bSize + 2;

                        return {
                            ...prev,
                            bottom: { ...prev.bottom, dim: bRunLen, count: estimatedCount },
                            sides: { ...prev.sides, dim: sideRunLen, count: estimatedCount * 2 },
                            top: { ...prev.top, dim: topL, count: estimatedCount },
                            karaHorz: { ...prev.karaHorz, count: 0 }, 
                            karaVert: { ...prev.karaVert, dim: kVertLen, count: estimatedCount * 2 } 
                        };
                    });
                }

            }, [dims.l, dims.w, dims.h, boxType, crateType, globalRunners, runnerConfig, supps.bottom.size, supps.karaHorz.size]);


            const handleGlobalRunnerChange = (val) => {
                const count = parseInt(val) || 2;
                setGlobalRunners(count);
            };

            const updateMainRow = (key, field, val) => {
                setMainRows(p => ({ ...p, [key]: { ...p[key], [field]: val } }));
            };

            const updateSupp = (key, field, val) => {
                setSupps(p => ({ ...p, [key]: { ...p[key], [field]: val } }));
            };
            
            const handleConfigChange = (key, val) => {
                setRunnerConfig(prev => ({...prev, [key]: val}));
            };

            const addExtra = () => setExtras(p => [...p, { id: Date.now(), l: 12, w: 3, t: 1, qty: 1, size: '3x1' }]);
            const removeExtra = (id) => setExtras(p => p.filter(x => x.id !== id));
            const updateExtra = (id, field, val) => {
                setExtras(p => p.map(x => x.id === id ? { ...x, [field]: val } : x));
            };

            const getRowCFT = (label, data) => {
                let effL = data.l;
                let effW = data.w;
                if (boxType === 'crate') {
                     let partName = '';
                     if (label.includes('Sides')) partName = 'Sides';
                     else if (label.includes('Kara')) partName = 'Kara';
                     else if (label.includes('Top')) partName = 'Top';
                     
                     if (partName) {
                         const specificBoxType = (crateType === 'simple') ? 'crateSimple' : 'crateBottom';
                         const res = getEffectiveCrateDims(partName, data.l, data.w, specificBoxType, crateSettings);
                         effL = res.l;
                         effW = res.w;
                     }
                }
                return calculateLineCFT(effL, effW, data.t, data.qty);
            };

            const totalBoard = getRowCFT("Top", mainRows.top) + 
                               getRowCFT("Bottom", mainRows.bottom) + 
                               getRowCFT("Sides", mainRows.sides) + 
                               getRowCFT("Kara", mainRows.kara);

            const sumSupp = (s) => {
                const d = getSizeDims(s.size);
                const feet = getPurchasedFeet(s.dim);
                return ((feet * d.w * d.t) / 144) * s.count;
            };
            
            const totalSupp = sumSupp(supps.bottom) + sumSupp(supps.sides) + sumSupp(supps.top) + 
                              sumSupp(supps.karaHorz) + sumSupp(supps.karaVert) + 
                              extras.reduce((acc,e) => acc + calculateLineCFT(e.l, e.w, e.t, e.qty), 0);
            
            const grandTotalCFT = totalBoard + totalSupp;
            const grandTotalCost = grandTotalCFT * costPerCFT;

            const isBottomType = (boxType === 'bottom' || (boxType === 'crate' && crateType === 'bottom'));

            return (
                <div className="min-h-screen pb-10 wood-pattern">
                    
                    {showStickyStats && (
                         <div className="fixed top-0 left-0 w-full bg-slate-900 z-[100] shadow-xl border-b-4 border-amber-600 animate-fade-in p-3 px-4">
                            <div className="max-w-2xl mx-auto flex justify-between items-center text-white">
                                <div>
                                    <div className="text-[10px] font-bold text-slate-400 uppercase tracking-widest">Internal Size</div>
                                    <div className="text-xl font-black text-amber-500 leading-none mt-1">
                                        {dims.l} <span className="text-slate-500 text-sm">x</span> {dims.w} <span className="text-slate-500 text-sm">x</span> {dims.h}
                                    </div>
                                </div>
                                <div className="text-right">
                                     <div className="text-[10px] font-bold text-slate-400 uppercase tracking-widest">Type</div>
                                     <div className="text-lg font-black text-white uppercase">{boxType}</div>
                                </div>
                            </div>
                         </div>
                    )}

                    <div ref={headerRef} className="bg-slate-900 text-white shadow-xl relative z-50 border-b-4 border-amber-600">
                        <div className="max-w-2xl mx-auto p-4 pb-4">
                            <div className="flex flex-col items-center justify-center text-center">
                                <h1 className="font-brand font-black text-2xl md:text-3xl text-amber-500 tracking-wide uppercase" style={{textShadow: '2px 2px 0px #000'}}>
                                    Ambica Wooden Works
                                </h1>
                                <p className="text-xs font-bold text-slate-400 uppercase tracking-[0.2em] mt-1">Smart CFT Calculator</p>
                            </div>
                        </div>
                    </div>

                    <div className="max-w-2xl mx-auto p-3 space-y-6 mt-4">

                        <div className="bg-slate-800 rounded-2xl p-6 shadow-[8px_8px_0px_0px_rgba(0,0,0,0.3)] border-4 border-amber-600 text-center">
                            <div className="text-sm font-black text-amber-500 uppercase tracking-[0.2em] mb-2">Total Project Cost</div>
                            <div className="text-6xl font-black text-white leading-none mb-6">
                                <span className="text-3xl text-amber-600 align-top mr-1">₹</span>
                                {Math.round(grandTotalCost).toLocaleString()}
                            </div>
                            
                            <div className="flex items-center justify-center gap-4 bg-slate-900 p-4 rounded-xl border border-slate-700">
                                <div className="flex flex-col items-center">
                                    <label className="text-xs font-bold text-slate-400 uppercase mb-1">Rate (₹/CFT)</label>
                                    <input 
                                        type="number" 
                                        value={costPerCFT} 
                                        onChange={(e) => setCostPerCFT(parseFloat(e.target.value) || 0)} 
                                        className="bg-white text-slate-900 font-black text-3xl w-32 p-2 rounded-lg text-center outline-none border-4 border-amber-500 focus:ring-4 focus:ring-amber-500/50" 
                                    />
                                </div>
                                <div className="h-12 w-0.5 bg-slate-600 mx-2"></div>
                                <div className="flex flex-col items-center">
                                    <span className="text-xs font-bold text-slate-400 uppercase mb-1">Total CFT</span>
                                    <span className="text-3xl font-black text-amber-400">{grandTotalCFT.toFixed(2)}</span>
                                </div>
                            </div>
                        </div>

                        <div className="bg-white p-5 rounded-2xl shadow-[4px_4px_0px_0px_rgba(0,0,0,0.2)] border-2 border-black">
                            <div className="flex justify-between items-center mb-4 border-b-2 border-slate-100 pb-2">
                                <h2 className="text-lg font-black text-black uppercase tracking-widest flex items-center gap-2">
                                    <Icons.Box className="text-amber-600" /> Internal Size
                                </h2>
                            </div>
                            <div className="grid grid-cols-3 gap-4">
                                {['l','w','h'].map(k => (
                                    <div key={k} className="flex flex-col">
                                        <label className="text-xs text-black font-black mb-2 uppercase tracking-wide bg-amber-100 w-full text-center py-1 rounded border border-amber-200">
                                            {k === 'l' ? 'Length' : k === 'w' ? 'Width' : 'Height'}
                                        </label>
                                        <input 
                                            type="number" 
                                            value={dims[k]} 
                                            onChange={(e) => setDims({...dims, [k]:e.target.value})} 
                                            className="bg-white border-4 border-slate-900 rounded-xl p-2 text-4xl font-black text-black text-center focus:ring-4 focus:ring-amber-200 focus:border-amber-600 outline-none transition-all" 
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>

                        <BoxTypeSelector 
                            type={boxType} setType={setBoxType} 
                            subType={crateType} setSubType={setCrateType}
                            crateSettings={crateSettings} setCrateSettings={setCrateSettings}
                        />

                        <div className="bg-white rounded-2xl shadow-[4px_4px_0px_0px_rgba(0,0,0,0.2)] border-2 border-black overflow-hidden relative" style={{height: '400px'}}>
                            <div className="absolute top-0 left-0 bg-black text-white px-3 py-2 text-xs font-black uppercase rounded-br-lg z-10 flex items-center gap-2">
                                <Icons.Rotate size={14} /> Tap & Drag to Rotate
                            </div>
                            <ThreeScene 
                                dims={dims} 
                                boxType={boxType} 
                                crateType={crateType} 
                                mainRows={mainRows}
                                supps={supps}
                                runnerConfig={runnerConfig}
                            />
                            <div className="absolute bottom-2 right-2 text-[10px] text-slate-400 font-bold bg-white/90 px-2 py-1 rounded border border-slate-200 pointer-events-none">
                                *Visualisation based on Calculated Cuts
                            </div>
                        </div>

                        <div className="bg-white rounded-2xl shadow-[4px_4px_0px_0px_rgba(0,0,0,0.2)] border-2 border-black overflow-hidden">
                            <div className="bg-slate-900 p-3 flex justify-between items-center">
                                <span className="font-black text-sm text-white uppercase tracking-wide">Box Components</span>
                                <span className="font-black text-xl text-amber-400">{totalBoard.toFixed(3)} <span className="text-xs text-slate-400">CFT</span></span>
                            </div>
                            
                            <div className="bg-slate-100 border-b-2 border-slate-300 p-2 grid grid-cols-12 gap-2 text-[10px] font-black text-slate-600 uppercase text-center tracking-widest">
                                <div className="col-span-3 text-left pl-1">Part</div>
                                <div className="col-span-2">Len</div>
                                <div className="col-span-2">Wid</div>
                                <div className="col-span-2">Thk</div>
                                <div className="col-span-1">Qty</div>
                                <div className="col-span-2 text-right">CFT</div>
                            </div>

                            <div className="p-3">
                                {!isBottomType && (
                                    <>
                                        <CalculationRow label="Top & Bottom" data={mainRows.top} onChange={(f,v) => {updateMainRow('top', f, v); updateMainRow('bottom', f, v);}} isCrate={boxType === 'crate'} crateSettings={crateSettings} boxType="crateSimple" />
                                        <CalculationRow label="Sides" data={mainRows.sides} onChange={(f,v) => updateMainRow('sides', f, v)} isCrate={boxType === 'crate'} crateSettings={crateSettings} boxType="crateSimple" />
                                        <CalculationRow label="Kara (Ends)" data={mainRows.kara} onChange={(f,v) => updateMainRow('kara', f, v)} isCrate={boxType === 'crate'} crateSettings={crateSettings} boxType="crateSimple" />
                                    </>
                                )}

                                {isBottomType && (
                                    <>
                                        <CalculationRow label="Bottom" data={mainRows.bottom} onChange={(f,v) => updateMainRow('bottom', f, v)} isCrate={false} crateSettings={crateSettings} boxType="crateBottom" />
                                        <CalculationRow label="Top Lid" data={mainRows.top} onChange={(f,v) => updateMainRow('top', f, v)} isCrate={boxType === 'crate'} crateSettings={crateSettings} boxType="crateBottom" />
                                        <CalculationRow label="Sides" data={mainRows.sides} onChange={(f,v) => updateMainRow('sides', f, v)} isCrate={boxType === 'crate'} crateSettings={crateSettings} boxType="crateBottom" />
                                        <CalculationRow label="Kara (Ends)" data={mainRows.kara} onChange={(f,v) => updateMainRow('kara', f, v)} isCrate={boxType === 'crate'} crateSettings={crateSettings} boxType="crateBottom" />
                                    </>
                                )}
                            </div>
                        </div>

                        <div className="space-y-4 pt-4 border-t-4 border-dashed border-slate-300">
                            <div className="flex items-center justify-between bg-black text-white p-5 rounded-2xl shadow-[4px_4px_0px_0px_rgba(0,0,0,0.4)]">
                                <div>
                                    <h3 className="font-black text-xl uppercase tracking-wide text-amber-500">Runners & Supports</h3>
                                    <p className="text-sm text-slate-300 font-bold mt-1">Total: {totalSupp.toFixed(3)} CFT</p>
                                </div>
                                
                                <div className="flex flex-col items-end">
                                    <span className="text-[10px] font-bold uppercase text-slate-400 mb-1">Global Override</span>
                                    <div className="flex items-center bg-white rounded-lg p-1">
                                        <button onClick={() => handleGlobalRunnerChange(globalRunners - 1)} className="w-10 h-10 flex items-center justify-center bg-slate-200 rounded hover:bg-slate-300 text-black font-black text-xl">-</button>
                                        <span className="w-12 text-center text-2xl font-black text-black">{globalRunners}</span>
                                        <button onClick={() => handleGlobalRunnerChange(globalRunners + 1)} className="w-10 h-10 flex items-center justify-center bg-amber-500 rounded text-black font-black text-xl hover:bg-amber-600">+</button>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <SupportCard 
                                    label="Bottom Supports"
                                    sizeOptions={['4x3', '3x2', '4x2', '4x1.5', '4x1', '3x1']}
                                    dimValue={supps.bottom.dim} 
                                    settings={supps.bottom}
                                    onUpdate={(f,v) => updateSupp('bottom', f, v)}
                                    colorClass="bg-amber-50 border-amber-900"
                                    configKey="bottomDir"
                                    runnerConfig={runnerConfig}
                                    onConfigChange={handleConfigChange}
                                    fixedDir={isBottomType ? 'Horizontal' : null}
                                />

                                <SupportCard 
                                    label="Side Supports"
                                    sizeOptions={['3x1', '4x1', '3x1.5', '4x1.5']}
                                    dimValue={supps.sides.dim}
                                    settings={supps.sides}
                                    onUpdate={(f,v) => updateSupp('sides', f, v)}
                                    configKey="sideDir"
                                    runnerConfig={runnerConfig}
                                    onConfigChange={handleConfigChange}
                                    fixedDir={isBottomType ? 'Horizontal' : null}
                                />

                                <SupportCard 
                                    label="Top Lid Supports"
                                    sizeOptions={['3x1', '4x1', '3x1.5']}
                                    dimValue={supps.top.dim}
                                    settings={supps.top}
                                    onUpdate={(f,v) => updateSupp('top', f, v)}
                                />

                                {!isBottomType && (
                                    <>
                                        <SupportCard 
                                            label="Kara Horizontal"
                                            sizeOptions={['3x1', '4x1']}
                                            dimValue={supps.karaHorz.dim}
                                            settings={supps.karaHorz}
                                            onUpdate={(f,v) => updateSupp('karaHorz', f, v)}
                                        />
                                        <SupportCard 
                                            label="Kara Vertical (Gap)"
                                            sizeOptions={['3x1', '4x1']}
                                            dimValue={supps.karaVert.dim}
                                            settings={supps.karaVert}
                                            onUpdate={(f,v) => updateSupp('karaVert', f, v)}
                                        />
                                    </>
                                )}
                                {isBottomType && (
                                    <SupportCard 
                                        label="Kara Vertical (Ends)"
                                        sizeOptions={['3x1', '4x1']}
                                        dimValue={supps.karaVert.dim}
                                        settings={supps.karaVert}
                                        onUpdate={(f,v) => updateSupp('karaVert', f, v)}
                                        fixedDir="Vertical"
                                    />
                                )}
                            </div>

                            {extras.map((ex) => (
                                <div key={ex.id} className="rounded-xl shadow-md border-2 border-blue-600 bg-white overflow-hidden mb-3">
                                    <div className="p-3 border-b border-blue-200 flex justify-between items-center bg-blue-50">
                                        <span className="text-sm font-black text-blue-800 uppercase tracking-wide">Extra Support</span>
                                        <div className="flex items-center gap-3">
                                            <span className="font-mono font-black text-xl text-amber-800">{calculateLineCFT(ex.l, ex.w, ex.t, ex.qty).toFixed(2)}</span>
                                            <button onClick={() => removeExtra(ex.id)} className="text-white bg-red-600 p-2 rounded-lg border-2 border-red-800 hover:bg-red-700 shadow-sm"><Icons.Trash size={20}/></button>
                                        </div>
                                    </div>
                                    <div className="p-4 space-y-3">
                                        <div className="grid grid-cols-5 gap-2">
                                            <div className="col-span-3">
                                                <label className="text-xs text-black font-black uppercase mb-1 block">Size</label>
                                                <select className="w-full border-2 border-slate-900 rounded-lg p-2 font-black text-black" value={ex.size} onChange={(e) => { const s = getSizeDims(e.target.value); updateExtra(ex.id, 'size', e.target.value); updateExtra(ex.id, 'w', s.w); updateExtra(ex.id, 't', s.t); }}>
                                                    <option value="Custom">Custom</option>
                                                    <option value="3x1">3 x 1</option>
                                                    <option value="4x1">4 x 1</option>
                                                </select>
                                            </div>
                                            <div className="col-span-1"><label className="text-xs text-black font-black uppercase mb-1 block">W</label><NumberInput value={ex.w} onChange={(v)=>updateExtra(ex.id,'w',v)} /></div>
                                            <div className="col-span-1"><label className="text-xs text-black font-black uppercase mb-1 block">T</label><NumberInput value={ex.t} onChange={(v)=>updateExtra(ex.id,'t',v)} step={0.25} /></div>
                                        </div>
                                        <div className="grid grid-cols-2 gap-3">
                                            <div><label className="text-xs text-black font-black uppercase mb-1 block">Length</label><NumberInput value={ex.l} onChange={(v)=>updateExtra(ex.id,'l',v)} /></div>
                                            <div><label className="text-xs text-black font-black uppercase mb-1 block">Qty</label><NumberInput value={ex.qty} onChange={(v)=>updateExtra(ex.id,'qty',v)} step={1} className="bg-blue-50" /></div>
                                        </div>
                                    </div>
                                </div>
                            ))}

                            <button onClick={addExtra} className="w-full py-5 bg-white border-4 border-dashed border-blue-300 text-blue-600 rounded-xl font-black hover:bg-blue-50 mt-4 flex justify-center items-center gap-2 shadow-sm uppercase tracking-wide text-lg transition-colors">
                                <Icons.Plus size={28}/> Add Extra Support
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
